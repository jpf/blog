---
title: "Do-it-yourself Gatsby â€“ Part II: Module bundling"
slug: "3-diy-gatsby-part-ii"
createdAt: "2021-09-14"
coverImage: "/content-assets/3/cover.png"
description: >
  A look into how module bundling works in the build system.
tags:
  - module bundling
  - rollup
  - react
  - gatsby
  - npm scripts
---

Now that we understand how SSR works, let's put it into practice. Part II focuses on how [Rollup](https://rollupjs.org/guide/en/), custom glue code, and templating are used to convert source files into pages that work in all browsers.

<Image alt="Directory structures" src="/content-assets/3/dir-structure-simple.svg" />

## Rollup

We need a way to convert `.tsx` source files into JS bundles. TypeScript compiler does the job in simple cases, but we want a full blown module bundler. _Why?_ Because module bundler is able to handle other tasks required to build a fast production site: tree shaking, bundle splitting, import aliases, `process.env` replacements, etc.

I looked into [Webpack](https://webpack.js.org/), [Snowpack](https://www.snowpack.dev/), [Parcel](https://parceljs.org/), [Rollup](https://rollupjs.org/), and [Babel](https://babeljs.io/). They all have a slightly different abstraction levels and philosophies, but Rollup was my choice for the task. Its configuration format is simple and the core is very minimal. Rollup allows precise low-level control over the bundling process.

More control usually equals more work. Rollup is no exception. Most tasks that Webpack and other bundlers do by default, need a plugin setup in Rollup. The configuration forces you to think about the details.

> If a dependency uses Node.js core library such as `crypto`, do you want to polyfill it?

It sounds tedious, but on the other hand it makes you very aware of what's happening under the hood. The payoff is increased understanding of the build process and most probably smaller bundle size.

This is how the simplified [rollup.config.js](https://github.com/kimmobrunfeldt/blog/blob/main/rollup.config.js) looks like:

```ts
export default {
  // Use tmp dir as a workaround. Ideally the output dir
  // would be modified in-place, but that didn't work with
  // Rollup for some reason.
  input: ["output-tmp-rollup/**/*.tsx", "output-tmp-rollup/**/*.ts"],
  output: {
    dir: "output",
    format: "esm",  // Use ES6 modules
  },
  plugins: [
    multiInput({
      // Keeps the output directory structure same as input
      relative: "output-tmp-rollup/",
    }),
    nodeResolve(),  // Allow importing under node_modules
    commonjs(),     // Required for dependencies using commonjs
    json(),         // Allow import data from './data.json'
    typescript(),
  ],
};
```

## Task runner

The bundler solves many complicated problems for us, but we also need a task runner to combine different tools together. [Grunt](https://gruntjs.com/) or [Gulp](https://gulpjs.com/) used to be the de-facto tools, but Webpack has taken over that territory too in many projects.

For this project though, I'm going to stick with my favorite approach: CLI tools and bash commands. For example HTML validation can be done with:

```bash
find ./output/ -name '*.html' html-validate {} +
```

The sweet spot for bash or Make-based build pipelines is in relatively simple setups. There's less API layers to learn, but the build time tends to be slower. The standardised plugin API makes it easier for Gulp and other tools to cache and optimise. Maybe it could be achieved with bash scripts, but I have yet to see a pipeline like that.

This is how the simplified [package.json](https://github.com/kimmobrunfeldt/blog/blob/main/package.json) scripts look like:

```js
{
  // ... in package.json
  "scripts": {
    "build": "npm run render && npm run rollup",
    "rollup": "rollup -c rollup.config.js",
    "render": "ts-node src/generator/render.tsx",
    // ... many more, such as PostCSS, linter, etc
  }
}
```

## Custom code & templates

We've chosen Rollup for module bundling, and [npm run scripts](https://www.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/) to combine tools together.

Next, we'll need custom code that iterates through all React pages and generates their static HTML counterparts. Everything starts from [src/render.tsx](https://github.com/kimmobrunfeldt/blog/blob/main/src/generator/render.tsx). Let's go through what it does.

*We'll skip many details, for example everything related to MDX. Going through them at once would be too much.*

### 1. Entrypoints

The entrypoints for React page components and their metadata is in [src/pages/_exports.ts](https://github.com/kimmobrunfeldt/blog/blob/main/src/pages/_exports.ts). Here's a simplified version of it:

```tsx
import { getData as getIndexData, default as Index } from "./Index";
import { getData as getPostsData, default as Posts } from "./Posts";

export const pages = [
  {
    // Async function in case a page needs to
    // fetch external data.
    getData: getIndexData,
    Component: Index,
    // Referred in pageHydrate.tsx:
    // import PageComponent from "src/pages/{{{ fileName }}}";
    fileName: "Index",
  },
  {
    getData: getPostsData,
    Component: Posts,
    fileName: "Posts",
  },
];
```

The list contains all the site pages, and which path to serve them from.

### 2. Iterate all pages

For each page in the entrypoints do the following operations.

Render the page HTML.

```tsx
const html = ReactDOMServer.renderToString(
  <page.Component pageData={pageData} siteData={siteData} />
);
```

Inject the page components's HTML and other data to [page.html.template](https://github.com/kimmobrunfeldt/blog/blob/main/src/templates/page.html.template). The template looks like this:

```html
<html>
  <head>
    <title>{{{ title }}}</title>
    <meta name="description" content="{{{ description }}}"/>
    <meta name="keywords" content="{{{ keywords }}}"/>

    <link defer rel="stylesheet" href="{{{ relativePathToRoot }}}styles.css"/>
  </head>
  <body>
    <div id="react-root">{{{ htmlContent }}}</div>
    <script type="module" src="{{{ hydrateScriptPath }}}"></script>
  </body>
</html>
```

Render the page-specific `hydrate.js` bundle by using [pageHydrate.tsx.template](https://github.com/kimmobrunfeldt/blog/blob/main/src/templates/pageHydrate.tsx.template). The template looks like this:

```tsx
import React from "react";
import ReactDOM from "react-dom";
import siteData from "site-data.json";
// Will be replaced with e.g. "src/components/pages/Posts"
import PageComponent from "{{{ pageImportPath }}}";

// Will be replaced with e.g. "/posts/"
const pagePath = "{{{ pagePath }}}";
const page = siteData.pages.find((page) => page.data.path === pagePath);

window.addEventListener("load", () => {
  ReactDOM.hydrate(
    <PageComponent pageData={page.data} siteData={siteData} />,
    document.getElementById("react-root")
  );
});
```

### 3. Save metadata to site-data.json

As seen in `pageHydrate.tsx.template`, `site-data.json` is passed to each page component in the hydrate process. Site-wide data is saved in a single cacheable JSON file, that is shared by all pages in the site.

```tsx
import fs from 'fs';
import { pages } from "src/pages/_exports";

const siteData = await mapAsync(pages, (page) => page.getData());
await fs.promises.writeFile(JSON.stringify(siteData), 'site-data.json', {
  encoding: 'utf-8'
});
```

That's how `src/render.tsx` works.

## Putting everything together

With these building blocks, `npm run build` will:

1. Render all templates with `src/render.tsx`
2. Run Rollup to transpile `tmp/**/*.tsx` files into `output/**/*.tsx`
3. Execute other build steps (copy static files, PostCSS, etc)

<Image alt="Directory structures" src="/content-assets/3/dir-structure-build.svg" />

The build flow is simple in theory, but there are a huge amount of details that end up making the process complicated.


*[SSR]: Server-side Rendering

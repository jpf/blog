---
title: "The ultimate Tailwind typings in a React project"
slug: "6-the-ultimate-tailwind-typings-in-a-react-project"
createdAt: "2021-10-20"
coverImage: "/content-assets/7/cover.png"
preview: true
description: >
  Making the ultimate TypeScript typings for Tailwind in a React project.
tags:
  - typescript
  - tailwind
  - types
  - advanced
---

This post is about making the ultimate Tailwind-React integration and typings for it. In the process, we'll learn about advanced TypeScript features including template literals and recursive types.

Sounds cool, but what's Tailwind? Their website describes the following:

> A utility-first CSS framework packed with classes like flex, pt-4, text-center and rotate-90 that can be composed to build any design, directly in your markup.

It's an accurate pitch. Tailwind produces plain CSS and doesn't require any specific JavaScript framework. We'll be focusing on using Tailwind in a TypeScript React project, but the typings work with any frontend framework.


## Prerequisite

Before presenting the desired typing solution, let's cover one crucial detail. Using Tailwind in dynamic components, such as in React, has [a vital rule](https://tailwindcss.com/docs/optimizing-for-production#writing-purgeable-html).

> It is important to avoid dynamically creating class strings in your templates with string concatenation, otherwise PurgeCSS wonâ€™t know to preserve those classes.

In other words, don't do this:

```tsx
<p className={`text-${color}`}>Hello!</p>
```

When doing string concatenation, Tailwind doesn't know which specific `text-` color classes to include in the CSS build. It uses a regex to find complete strings from the source code, to detect which Tailwind classes are actually used in the project. This process of minification is called purging. You can safelist special cases and even regex class name patterns, but it's tedious and can lead to large CSS output.

Purging is important, because there is a huge amount of possible combinations of class names. There's actually tens of thousands of them! Unpurged `output.css` from Tailwind can weigh even 8 megabytes.


It sounds scary, but in reality your application will use only a fraction of them. Maybe a few thousands at maximum, which totals to some 10kB.

![Tailwind class names Venn diagram](/content-assets/6/tailwind-classes-venn.svg)

Now that we know this limitation, the following decisions make more sense.

## The desired result

The problem we are solving in its shortest form is: *What's the cleanest way to implement a function that transforms component props into class names?*

In other words, we should implement a function with signature `(props: Props) => string`.

There are multiple ways to achieve the goal, but to me the perfect balance is using a solution like [classnames](https://www.npmjs.com/package/classnames). It's great as is, but there's nothing guarding you from typos or using class names that were purged for some reason.

The solution is to implement strict typings on top of *classnames*. Let's call the new function `cn`. A wrapper for *classnames*, but with strict types.

```typescript
import classnames from 'classnames'

// TODO: Implement typings
const cn = (...args: Todo) => classnames(...args)
```

After implementing the types, we should be able to catch all the incorrect calls:

```typescript
const Hello = () => {
  // typo in regular string
  return <p className={cn(`text-blaxk-100 bg-white`)}>
    Hello!
  </p>
}

const Hello2 = ({ dense }: Props) => {
  return <p className={cn(`text-black-100 bg-white`, {
    // typo in object key format
    'px-asd2 py-1 my-2': dense,
    'px-3 py-2 my-3': !dense,
  })}>
    Hello!
  </p>
}

const Hello2 = ({ dense }: Props) => {
  return <p
    // long class name definition, with a typo
    // note the leading and trailing spaces
    // on each line
    className={cn(`
      flexxx
      text-black-100 bg-white
      hover:text-black-300
      hover:border-b-2
    `, {
      'px-1 py-3 my-4': dense
      'px-2 py-4 my-6': !dense,
    })}
  >
    Hello!
  </p>
}
```





## Conditional types




## Flatten array or object types into a union

By using [Indexed Access Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html), we can flatten array item types into a union type.

```typescript
// const array: (string | number | string[])[]
const array = [1, 'test', ['array']]

// type Item = string | number | string[]
type Item = typeof array[number]
```

Pretty neat! By accessing the array's type with `number`, we access
all possible indexes from the array type which results into union of its item types.

The same can be done for object's values, by using `keyof Obj`.

```typescript
// const obj: { num: number; str: string; arr: string[]; }
const obj = {
  num: 1,
  str: 'test',
  arr: ['array']
}

// type Item = string | number | string[]
type Item = typeof obj[keyof typeof obj]
```

[Playground link](https://www.typescriptlang.org/play?#code/PTAEGMHsDsGcBdQEMBOKkE8BcoAUCUBLaAc1AB9RoBXAWwCMBTFC0A4kgbQF0BKHgFBQ4iVOgygAvKE4BGADSgA5PEYIlizkrGYl3bgIEhQ8DAAdGoAJKraUtvCKlWNBs1btSg0xeu37PoyQAGbIaJicrkwoBkZgwgigkPQAVjgA3lR0OFHMANwOKDieJAVixY4cPAUAvkIwickp9ukCoFm0OApthTgqavAaPeUy2uEYegJ1cSbmlgBqSAA21JbSJS500R6VXgaBoIsra7MWIUmpnADWjBjngedN3EA)


## Iterate object's key-value types

As an example, let's convert object's value types to nullable. To do this, we'll use [Mapped types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html).

```typescript
// const obj: { num: number; str: string; arr: string[]; }
const obj = {
  num: 1,
  str: 'test',
  arr: ['array']
}

// Alias for convenience
// type Obj = { num: number; str: string; arr: string[]; }
type Obj = typeof obj

// type NullableObj = {
//   num: number | null
//   str: string | null
//   arr: string[] | null
// }
type NullableObj = {
  // Declarative way to iterate over each key in Object
  [Key in keyof Obj]: Obj[Key] | null
}


```

Using `Key in keyof Obj` as the key, tells typescript that you want to deal with each key separately. `Key` will become a temporary type variable, that can be used to index `Obj` or any other type.


## Use generics to make type functions

Generics can be thought as type functions. They get inputs as type arguments, and their return values are types. These functions call other type functions and even themselves to implement recursion.

Let's create a generic `MakeNullable` utility type that converts an object type `T` into a version where each value type can be nullable.

```typescript
// const obj: { num: number; str: string; arr: string[]; }
const obj = {
  num: 1,
  str: 'test',
  arr: ['array']
}

type MakeNullable<T> = {
  [Key in keyof T]: T[Key] | null
}

type NullableObj = MakeNullable<typeof obj>
```

## Convert deep structures with recursive generics

To 1-up the previous example, let's make a generic type `MakeNullableDeep` that deeply converts all object value types to nullable.

```typescript
// const obj: { num: number; str: string; arr: string[]; }
const obj = {
  num: 1,
  str: 'test',
  arr: ['array']
}

// Use alias for convenience
// type Obj = { num: number; str: string; arr: string[]; }
type Obj = typeof obj

// The generic type takes one type argument `T`, which will
// be converted to a version where each value can be nullable
type MakeNullableObj<T> = {
  [Key in keyof T]: T[Key] | null
}
```

## Write complex types from scratch

TypeScript supports conditionals, looping with recursion, and all kinds of advanced features, but with very limited syntax. Regular programming provides tools to make the code readable, but TypeScript offers quite little.

To understand a complex generic type, it's often easiest to write it from scratch. I've spent a ton of time trying to decode what different generic types mean, without great results. Often the shortest route to understanding has been a rewrite.

Writing the type again piece by piece might reveal that it wasn't that complex after all. Complexity is often a cause of the limited syntax.


## Don't use T for everything

Generics often use very cryptic type argument names. I'm not sure where the trend originates from, but it's not great for readability. I think the same naming rules apply as for regular code. Be descriptive. Instead of just `T`, you can name the type argument more explicitly, for example `Request` or `RequestT`.

Marcin Wanago has written an insightful post about [TypeScript naming conventions](https://wanago.io/2020/02/17/typescript-generics-discussing-naming-conventions/).

---
title: "Making a do-it-yourself Gatsby"
slug: "2-making-diy-gatsby"
createdAt: "2021-03-04"
coverImage: "/content-assets/2/cover.png"
description: >
  Over-engineering can be a great learning experience. If it feels fun,
  just go for it! Casual projects can break the rules.
tags:
  - over-engineering
  - react
  - server-side rendering
  - gatsby
---

Gatsby has many more features than the self-rolled site generator this blog has been built with. In any case, the custom generator works. It's been a great way to get to know [rollup](https://rollupjs.org/), React static site rendering, and [ES6 modules](https://hacks.mozilla.org/2015/08/es6-in-depth-modules/).

At the beginning, I already had some ideas for the site build pipeline and developer experience:

* Output should be a static site directory
* *Unix-style* build pipeline using CLI tools and file transforms
* MDX support for content
* Minimal page bundle size
* Hot reloading is not mandatory
* No frontend routing or data fetching


*Let's start building the tooling.*


![Build pipeline overview](/content-assets/2/build-pipeline-overview.svg)


Since the tooling is custom-made, it can be opinionated in many areas. Gatsby is a general purpose tool that allows a lot of flexibility. Many areas can be customised: data sources, build pipeline, or functionality via plugins. Gatsby also needs to support async data sources such as Contentful, so it has nicely wrapped the sources behind a GraphQL API. It's a good standardised way to allow pages to access data.

But in some cases solving something in a generic way, makes it less optimal for single use cases. Plugin architecture is a good example of that.

## How does the generator work?

The aim was a simple build pipeline that is a bunch of CLI commands. The end result is quite simple considering the task, but lack of hot reloading makes the iteration somewhat slow (5-10s after each file change).

![Build pipeline](/img/2/build-pipeline.svg)


Production build with approximate times:

### 1. Generate pages

For each regular page under [src/pages](https://github.com/kimmobrunfeldt/blog/blob/main/src/pages), generate:

  * `index.html` the main HTML for the page.
  * `hydrate.tsx` the script that `React.hydrate`s the given page when loaded at frontend. *The static parts of the page work without this script.*

For each MDX post under [posts/](https://github.com/kimmobrunfeldt/blog/blob/main/posts), generate:

* `index.html`
* `<postName>-post-hydrate.tsx` same as above, except it imports `PostPage` component that is also generated dynamically
* `<postName>-post.tsx` responsible for hydrating the MDX content

    Note that hydrate is *not* the same as `React.hydrate`. Instead it uses [next-mdx-remote](https://github.com/hashicorp/next-mdx-remote/)'s
    hydrate. The flow is:

    * Node.js process renders MDX content to HTML string, and also transpiles the MDX content into a React component code. The code is quite short and well commented: https://github.com/hashicorp/next-mdx-remote/blob/main/render-to-string.js

    * Frontend takes in the rendered HTML, and babel transpiled component code and starts the dynamic components in frontend. See [next-mdx-remote/blob/main/hydrate.js)](https://github.com/hashicorp/next-mdx-remote/blob/main/hydrate.js)

* `compiledSource.txt` The MDX component source code transpiled with Babel, mentioned above

    We need to be able to transfer the text contents exactly as-is to the frontend. A good way to do this
    was using a rollup text plugin, which is used in the next steps. `.txt` extension is used just to make
    configuring the rollup plugin easier.

    It used to be just a simple regex
    replacement in `<postName>-post.tsx` file, but it broke with line breaks.

* `renderedOutput.txt` The HTML content of the MDX blog post.

* `site-data.json` file that contains all metadata of the site, including pages
* `prism-theme.css` contains dynamically rendered Prism theme CSS, based on [tailwind.config.js](https://github.com/kimmobrunfeldt/blog/blob/main/tailwind.config.js)

### 2. Bundle pages

Bundles the dynamically created files for each page to one JS bundle per page

Rollup seemed like a good fit for this type of setup where we want absolute control over the build. Rollup requires quite precise configuration, the following plugins are used:

* `replace` module to e.g. take either dev or prod version of React
* `nodeResolve` module to make rollup follow `require('react')` calls into node_modules and include them into the bundle
* `string` to include the text files in JS code
* `commonjs`
* `json` to be able to import json file (site data)
* `typescript`

### 3. PostCSS

Generate distributable CSS file with PostCSS. The site uses Tailwind for CSS styling.


### 4. Copy static files

Copy everything from [public/](https://github.com/kimmobrunfeldt/blog/blob/main/public/) to the root of output.

### 5. Minify

Validate accssibility of the HTML and minify the output.

### 6. Generate RSS

Generate RSS feed of the posts using [node-rss](https://www.npmjs.com/package/rss).

### 7. Lighthouse

Build a Lighthouse CI report which is deployed to https://kimmo.blog/perf. It is being ran in Netlify's slow build machine, so performance shows lower than it should.

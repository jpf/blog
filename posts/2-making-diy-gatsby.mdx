---
title: "Making a do-it-yourself Gatsby"
slug: "2-making-diy-gatsby"
createdAt: "2021-03-04"
coverImage: "/content-assets/2/cover.png"
description: >
  Over-engineering can be a great learning experience. If it feels fun,
  just go for it! Casual projects can break the rules.
tags:
  - over-engineering
  - react
  - server-side rendering
  - gatsby
---

Let's jump straight into building the tooling. The high level idea is pretty straightforward: convert a bunch of source files and content to a static site `output/` directory.

<Presentic alt="Build pipeline overview presentation" maxWidth="65%" duration={1200} src="/content-assets/2/build-pipeline-overview.svg" initialAnimateToSlide={1} />


We ["simply"](https://www.knowledgeowl.com/home/dont-say-simply-jim-fisher) need to implement the Build pipeline box in the middle.

One way to start figuring out a system is from the usage perspective. If a user loads `/posts/` path in their browser, the server would send `output/posts/index.html` file back. In single page apps, the server is usually configured to send the same `index.html` for each path. JavaScript would then read `window.location` and decide which page content to render. But we don't want that. We want a static site that can be hosted in S3 or any simple hosting provider.

When the server sends `output/posts/index.html` to the user, the content should exist in the HTML before browser even parses JavaScript. This way, the content loads faster, is SEO friendly, and is accessible even when JS has been disabled.

That covers the read-only content, but for richer interaction we need to generate a JS bundle that kicks off the dynamism. Using the same example, we need to generate a `output/posts/hydrate.js` that will be loaded from the HTML.

Compared to [SPAs](https://en.wikipedia.org/wiki/Single-page_application), static sites have multiple possible entrypoints into the application. Each page needs to be able to bootstrap the JavaScript UI. The blog uses React, but the same basic principles apply to all frameworks.

Let's start with how `output/posts/index.html` looks like:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Posts - kimmo.blog</title>
  </head>
  <body>
    <div id="react-root">
      <!-- Content that is rendered on site generation -->
    </div>
    <script type="module" src="./hydrate.js"></script>
  </body>
</html>
```

The content is rendered inside the `<div>` using [`ReactDOM.renderToString()`](https://reactjs.org/docs/react-dom-server.html#rendertostring) at site generation phase. The `hydrate.js` is generated with a template:

```tsx
import React from "react";
import ReactDOM from "react-dom";
import siteData from "site-data.json";
// Will be replaced with e.g. "src/components/pages/Posts"
import PageComponent from "{{{ pageImportPath }}}";

const reactRoot = "react-root";
// Will be replaced with e.g. "/posts/"
const pagePath = "{{{ pagePath }}}";
const page = siteData.pages.find((page) => page.data.path === pagePath);

window.addEventListener("load", () => {
  ReactDOM.hydrate(
    <PageComponent pageData={page.data} siteData={siteData} />,
    document.getElementById(reactRoot)
  );
});
```




loads up a browser router th All paths need to have corresponding directory structure.




Module bundler sounds like the next step. I looked into [Webpack](https://webpack.js.org/), [Snowpack](https://www.snowpack.dev/), [Parcel](https://parceljs.org/), [Rollup](https://rollupjs.org/), and [Babel](https://babeljs.io/). They all have a slightly different abstraction levels and philosophies, but _Rollup_ was my choice for the task. Its configuration format is simple and the core is very minimal. _Rollup_ allows presice low level control on the bundling process.

More control usually equals more work. _Rollup_ is no exception. Most tasks that Webpack and other bundlers do by default, need a plugin setup in _Rollup_. The configuration forces you to think about the details. If a dependency uses _Node.js_ core library such as `crypto`, do you want to polyfill it? It sounds tedious, but on the other hand it makes you very aware of what's happening under the hood. The payoff is increased understanding of the system and most probably smaller bundle size.

The bundler solves many complicated problems for us, but we still need to implement the glue logic that brings the site together. We need to iterate through all React pages and MDX posts, and generate their static HTML counterparts.


This is often [Gulp](https://gulpjs.com/) or Webpack territory, but this task seems even more custom work.


I personally favor CLI tools and bash commands. For example the HTML validation is done with `find ./output/ -name '*.html' html-validate {} +`.

The sweet spot for bash or Make based build pipelines is in relatively simple setups. There's less API layers to learn, but the build time tends to be slower. The standardised plugin API makes it easier for *Gulp* and other tools to cache and optimise. Maybe it could be achieved with bash scripts as well, but I have yet to see a pipeline like that.

At this point we've chosen Rollup for module bundling, and [npm run scripts](https://www.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/) based build pipeline. Next we need to implement the actual "Gatsby" part.



Since the tooling is custom-made, it can be opinionated in many areas. Gatsby is a general purpose tool that allows a lot of flexibility. Many areas can be customised: data sources, build pipeline, or functionality via plugins. Gatsby also needs to support async data sources such as Contentful, so it has nicely wrapped the sources behind a GraphQL API. It's a good standardised way to allow pages to access data.

But in some cases solving something in a generic way, makes it less optimal for single use cases. Plugin architecture is a good example of that.

## How does the generator work?

The aim was a simple build pipeline that is a bunch of CLI commands. The end result is quite simple considering the task, but lack of hot reloading makes the iteration somewhat slow (5-10s after each file change).

<Image alt="Build pipeline" src="/content-assets/2/build-pipeline.svg" maxWidth="80%" />

Production build with approximate times:

### 1. Generate pages

For each regular page under [src/pages](https://github.com/kimmobrunfeldt/blog/blob/main/src/pages), generate:

  * `index.html` the main HTML for the page.
  * `hydrate.tsx` the script that `React.hydrate`s the given page when loaded at frontend. *The static parts of the page work without this script.*

For each MDX post under [posts/](https://github.com/kimmobrunfeldt/blog/blob/main/posts), generate:

* `index.html`
* `<postName>-post-hydrate.tsx` same as above, except it imports `PostPage` component that is also generated dynamically
* `<postName>-post.tsx` responsible for hydrating the MDX content

    Note that hydrate is *not* the same as `React.hydrate`. Instead it uses [next-mdx-remote](https://github.com/hashicorp/next-mdx-remote/)'s
    hydrate. The flow is:

    * Node.js process renders MDX content to HTML string, and also transpiles the MDX content into a React component code. The code is quite short and well commented: https://github.com/hashicorp/next-mdx-remote/blob/main/render-to-string.js

    * Frontend takes in the rendered HTML, and babel transpiled component code and starts the dynamic components in frontend. See [next-mdx-remote/blob/main/hydrate.js)](https://github.com/hashicorp/next-mdx-remote/blob/main/hydrate.js)

* `compiledSource.txt` The MDX component source code transpiled with Babel, mentioned above

    We need to be able to transfer the text contents exactly as-is to the frontend. A good way to do this
    was using a rollup text plugin, which is used in the next steps. `.txt` extension is used just to make
    configuring the rollup plugin easier.

    It used to be just a simple regex
    replacement in `<postName>-post.tsx` file, but it broke with line breaks.

* `renderedOutput.txt` The HTML content of the MDX blog post.

* `site-data.json` file that contains all metadata of the site, including pages
* `prism-theme.css` contains dynamically rendered Prism theme CSS, based on [tailwind.config.js](https://github.com/kimmobrunfeldt/blog/blob/main/tailwind.config.js)

### 2. Bundle pages

Bundles the dynamically created files for each page to one JS bundle per page

Rollup seemed like a good fit for this type of setup where we want absolute control over the build. Rollup requires quite precise configuration, the following plugins are used:

* `replace` module to e.g. take either dev or prod version of React
* `nodeResolve` module to make rollup follow `require('react')` calls into node_modules and include them into the bundle
* `string` to include the text files in JS code
* `commonjs`
* `json` to be able to import json file (site data)
* `typescript`

### 3. PostCSS

Generate distributable CSS file with PostCSS. The site uses Tailwind for CSS styling.


### 4. Copy static files

Copy everything from [public/](https://github.com/kimmobrunfeldt/blog/blob/main/public/) to the root of output.

### 5. Minify

Validate accssibility of the HTML and minify the output.

### 6. Generate RSS

Generate RSS feed of the posts using [node-rss](https://www.npmjs.com/package/rss).

### 7. Lighthouse

Build a Lighthouse CI report which is deployed to https://kimmo.blog/perf. It is being ran in Netlify's slow build machine, so performance shows lower than it should.

### TODO

* Add svg fonts

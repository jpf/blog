---
title: "DIY Gatsby – Part IV: Conclusion"
slug: "5-diy-gatsby-part-iv"
createdAt: "2021-09-06"
coverImage: "/content-assets/5/cover.png"
preview: true
description: >
  The fourth post of a series where we'll look into how this blog was made. Part IV focuses on the pros and cons of the DIY build system.
tags:
  - static site generator
  - react
  - server-side rendering
  - gatsby
---

*This is the Part&nbsp;IV of a series where we'll look into how kimmo.blog works. Part&nbsp;IV focuses on the pros and cons of the DIY build system.*

*Motivation has been covered in [Writing, or coding](../1-writing-or-coding/).*

## DIY vs Gatsby

Before diving into details, let's look at a classic feature comparison table.

Feature | DIY | Gatsby
--------|:----:|:-------:
Site generator | <InlineIcon icon={tickOutlineIcon} /> | <InlineIcon icon={tickOutlineIcon} />
Great end-user performance | <InlineIcon icon={tickOutlineIcon} /> | <InlineIcon icon={tickOutlineIcon} />
MDX | <InlineIcon icon={tickOutlineIcon} /> | <InlineIcon icon={tickOutlineIcon} />
Frontend routing  | <InlineIcon icon={xSmallOutlineIcon} /> | <InlineIcon icon={tickOutlineIcon} />
Custom data sources  | <InlineIcon icon={xSmallOutlineIcon} /> | <InlineIcon icon={tickOutlineIcon} />
Documentation  | <InlineIcon icon={xSmallOutlineIcon} /> | <InlineIcon icon={tickOutlineIcon} />
Community  | <InlineIcon icon={xSmallOutlineIcon} /> | <InlineIcon icon={tickOutlineIcon} />

Even though the title hints that we'd build a competitor for Gatsby, we've covered only a small fraction of the whole ecosystem. There are benefits to the custom approach sure, but it's just not a matching offering.

That said, the lack of features also means less code and smaller bundles.

Let's go through the good and the bad.


![Positive image](/content-assets/5/jason-leung-60j0UB-Z_Yk-unsplash.jpg)

## Good #1: Technical simplicity

My thoughts are biased because I've incrementally gathered knowledge while developing the blog. But even knowing that, I'd still claim that the build system is pretty simple considering how much it does.

The simplicity has been achieved by keeping the amount of abstraction levels minimal. A few examples:

* Build steps operate on directories and files
* Each build step is a narrowly scoped CLI command
* Modern standards (e.g. ESM) are leveraged
* Data is plain JSON

Part of the minimalism can be attributed to the amount of use cases. Gatsby supports thousands of use cases, while the custom-tailored tooling caters just this blog.

There's another unfortunate side to this argument though. Simplicity has been obtained with the cost of build speeds. More on this later.

## Good #2: Rollup bundling

By leveraging Rollup and [ES6 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules), the bundling becomes intuitive. Instead of a single large bundle.js, source code and its dependencies are bundled into separate cachable files.

ES6 modules are used in the development environment as well as in the production site. Because this is a developer-focused blog, I can just ignore the browsers that [don't support ESM](https://caniuse.com/?search=esm).

![Chrome Devtools](/content-assets/5/devtools.jpg)

Dependencies are bundled under `node_modules` directory, for example `/node_modules/lodash.js`. It makes the developer experience familiar, and there's an awesome side-effect: the network panel can be directly used as to see which dependencies weigh the most. No need for an external bundle analyzer tool! This is achieved with Rollup's [manual bundle chunking](https://github.com/kimmobrunfeldt/blog/blob/8e261e0cc61ecf165f2e291afeb6450243cf79ad/rollup.config.js#L58-L75).

Sounds like a neat setup, *why isn't this used more widely?*

One big reason probably is that the approach used to be a performance killer in HTTP/1.1. However, nowadays doing multiple requests is just fine! Multiplexing in HTTP/2 solved the network bottleneck. Another reason would be that ES6 modules are a fairly new standard (browser support landed on 2017). Fortunately the tools are improving every day: [Snowpack](https://www.snowpack.dev/) uses ESM exclusively and many frontend packages in npm are shipping only the ESM bundles for the latest versions.

A downside that must be mentioned is that browser needs to do multiple request-response round trips to be able to fetch all relevant files in the module tree. For example:

Browser loads `index.html` _(1)_ which refers to a JS module.

```html
<script type="module" src="./hydrate.js"></script>
```

Browser requests `hydrate.js` _(2)_ from the server and parses the file. There's a new import inside.

```tsx
import App from "./app.js"
```

Browser requests `app.js` _(3)_ from the server. There's yet another import.

```tsx
import PostsPage from "./pages/Posts.js"  // (4)
```

This continues until we've reached the final leaf module in the import tree.

The example had 4 rounds-trips between the browser and the server. The process is slow and web performance tools often report about chaining requests. I'm not sure what the real fix would be but maybe [import maps](https://github.com/WICG/import-maps) will help in the future.


## Good #3: Something

Something here.


Another point.


![Negative image](/content-assets/5/matthew-brodeur-zEFyM4sulJ8-unsplash.jpg)


## Bad #1: Something

This is going to be bad.

* Even though it is technically simpler than Gatsby, it's not easier to onboard anyone else to the project.
* Complicated, I made my own framework with bad documentation and no tests
* Slow dev iteration
* Rollup config had some pitfalls


*[ESM]: ES6 Modules
*[DX]: Developer experience
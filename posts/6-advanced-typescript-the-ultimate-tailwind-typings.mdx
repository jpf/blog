---
title: "Advanced TypeScript — The ultimate Tailwind typings"
slug: "6-advanced-typescript-the-ultimate-tailwind-typings"
createdAt: "2021-10-20"
coverImage: "/content-assets/7/cover.png"
preview: true
description: >
  Making the ultimate TypeScript typings for Tailwind class names in a React project.
tags:
  - typescript
  - tailwind
  - types
  - advanced
  - react
---

This post is about implementing the ultimate Tailwind-React integration and typings for it.

In the process, we'll learn about most of the advanced TypeScript features including complex conditionals, template literals, and recursive types. The typings are demonstrated via React components, but the final solution works in any TypeScript project.

To get an idea what we're building, you can check out the final monstrous type in [TypeScript playground](https://www.typescriptlang.org/play?#code/C4TwDgpgBAwgNgQwM5IHIILbQLwCgpQA+UA5AEZwD2AxgNYn5EAFJAlgHZwcQC0FN9RsRIAzOBAAeDAsIDmAJ1YATaUVJlZPBQhA8AjAAYDq4WH2qA9BagA6O1ARRgAC0oBXJAnZLcjUJCgASXYkYC9gVgQIynYAEQgwFwAlCCU3ag5ZAHVnVmAIJDAEahwhUgJSMpICE3LakgAddgZcf2gAFUUMABkIBCVMgB52qEl87yQoUMV2WQA+KDwCEbGICagAAwASAG9g0PDI6LiE5NT0zJy8gqKSgF9djhEIeSh2hFY4O43GAgB+N5dXr9IbvT5zX5QABcb18bUBrAwnQ+XFmw1GEnGSkm00yCyWbwxWMm2x2TxeUAACvIICJWBIHnsQmF2BEoqwYvFEs4UmkMrMrvlCsUIN9IQDOojkZ8htTafSIRVobDWuAOl10at1rjZviEUj5CjQUC+gM0e05hDVQEAMpgLjAdqUMFwADuHCU8GQaEwBU1mLW2KmwBm80WjBWAfWpK9KHQWEZ5NeLrFSolRMDJMe7GerxgjJTPyV-ygAG0YAAaWx2O0Op0u93eWM+rBIYYal2WgC6kIIMPYEAAbi9fEqrFAAIJKJSpUbyeSUV7OLxKVGySEwyPEzbZ3NvFGp4sSlEZ9bN+MQXsVAGll094sVTcdlELLVBgBE76vabL94fj7LAdh3kP8lRhUsgJeHs4TVKAACFFigWs8nrFFG09RA419NsSBsAh+DoKACNoUgrXhABRCRMHtCB-W3HUw2wKAI1PINz19cVYTAzZyPnRcYRIXZ2juapWEmdhKGABwoEHBAuCUfdPnQqBqEwpAfmtaAJ0QyjqPEQYSBIMjYMCJAADU5OUOjM2DUM9RYt9JnYrBOPaDceL4+QBKEkSoDEqAJKkxxZPkxS3Q9FS1I0kQ3HYahjhU9hrO1EM8QACiQTJxGciAYVMiz5OGOYAEooB2RgaWANx5HYKYsogHKAG5cDuXxqHYNKSCFYASGKtqYlCaSmPIKg6AYdq0oQYqgA).


## Quick intro to Tailwind

Tailwind's website has an accurate pitch that describes its purpose well:

> A utility-first CSS framework packed with classes like flex, pt-4, text-center and rotate-90 that can be composed to build any design, directly in your markup.

If you're sceptical about Tailwind in general, I suggest reading [CSS Utility Classes and "Separation of Concerns"](https://adamwathan.me/css-utility-classes-and-separation-of-concerns/) by Adam Wathan.

Anyways, Tailwind produces plain CSS, everything is customisable via the config file, and its public API is the class names.


### Prerequisites

The first prerequisite is about string concatenation. Using Tailwind in dynamic components, such as in React, has [one vital rule](https://tailwindcss.com/docs/optimizing-for-production#writing-purgeable-html).

> It is important to avoid dynamically creating class strings in your templates with string concatenation, otherwise PurgeCSS won’t know to preserve those classes.

In other words, don't do this:

```tsx
<p className={`text-${color}`}>Hello!</p>
```

When doing string concatenation, Tailwind doesn't know which specific `text-` color classes to include in the CSS build. It uses a regex to find complete strings from the source code, to detect which Tailwind classes are actually used in the project. This process of minification is called purging. You can safelist special cases and even regex class name patterns, but it's tedious and can lead to large CSS output.

Purging is important, because there is a huge amount of possible combinations of class names. There's actually tens of thousands of them! Unpurged `output.css` from Tailwind can weigh even 8 megabytes.


It sounds scary, but in reality your application will use only a fraction of them. Maybe a few thousands at maximum, which totals to some 10kB.

![Tailwind class names Venn diagram](/content-assets/6/tailwind-classes-venn.svg)


The second prerequisite is that Tailwind class names have equal specificity.  You can't override previously written class names as you might intuitively expect:

```tsx
<button className="rounded p-4 flex p-0">Ok</button>
```

In the above example `p-0` does not override `p-4`. Whichever class is defined first in Tailwind's `output.css` wins. That's how CSS specificity works. Another example for a real use case:

```tsx
// Doesn't work
const baseCls = "rounded p-4 bg-primary hover:cursor-pointer"
const disabledCls = "bg-gray-200 hover:cursor-not-allowed"

const finalCls = `
  ${baseCls}
  ${props.disabled ? disabledCls : ''}
`;


// Do this instead
const baseCls = "rounded p-4"
const primaryCls = "bg-primary hover:cursor-pointer"
const disabledCls = "bg-gray-200 hover:cursor-not-allowed"

const finalCls = `
  ${baseCls}
  ${props.disabled
    ? disabledCls
    : primaryCls
   }
`;
```

Here's a [GitHub issue discussion](https://github.com/tailwindlabs/tailwindcss/issues/1010) about this commonly appearing topic.


Now that we know these limitations, the following decisions make more sense.


## The desired result

React components have changing props, but Tailwind doesn't like dynamically created class names. The problem could be framed: *What's the cleanest way to implement a function that transforms component props into Tailwind class names while adhering to the limitations?*

It sounds like a trivial task. However, implementing it in a clean and readable way with all the constraints in mind is another story.

There are multiple ways to dynamically format `className` strings, but to me [classnames](https://www.npmjs.com/package/classnames) provides the perfect balance of readability and convenience. It's great as is, but there's nothing guarding you from typos or using Tailwind class names that were purged for some reason.

What we want is *classnames*, but with strict typings. Let's call this new more strict function `cn`.

```typescript
import classnames from 'classnames'

// TODO: Implement typings
const cn = (...args: Todo) => classnames(...args)
```

After implementing the types, we should be able to catch all the incorrect calls at type-level:

```typescript
const Hello = () => {
  // typo in regular string
  return <p className={cn(`text-blaxk-100 bg-white`)}>
    Hello!
  </p>
}

const Hello2 = ({ disabled }: Props) => {
  return <p className={cn([
    'flex my-5',
    // typo in a string in the array format
    `text-blaxk-100 bg-white`,
    disabled ? 'bg-gray-100 cursor-not-allowed'
  ])}>
    Hello!
  </p>
}

const Hello3 = ({ dense }: Props) => {
  return <p className={cn(`text-black-100 bg-white`, {
    // typo in object key format
    'px-asd2 py-1 my-2': dense,
    'px-3 py-2 my-3': !dense,
  })}>
    Hello!
  </p>
}

const Hello4 = ({ dense }: Props) => {
  return <p
    // long class name definition with a typo.
    // note the leading and trailing spaces
    // on each line
    className={cn(`
      flexxx
      text-black-100 bg-white
      hover:text-black-300
      hover:border-b-2
    `, {
      'px-1 py-3 my-4': dense
      'px-2 py-4 my-6': !dense,
    })}
  >
    Hello!
  </p>
}
```

To me, that's the holy grail. Let's start implementing!


## Implementation

The final typings serve as a neat real-life example that covers almost all advanced features in TypeScript. The individual pieces we need for the desired outcome are:

1. Type containing all valid Tailwind class names. For example `type ClassName = 'p-1' | 'p-2' | 'etc'`.
1. Type that trims leading and trailing whitespace of strings.
1. A way to split the whole `className` string into word tokens and validate them against `ClassName`.
1. Error message type that shows which is the offending token. For example `'flexxx' is not a valid Tailwind class`.
1. Support all of the above for string, object, and array types.

Let's cover them one by one, and tie it all together in the end.

### 1. Tailwind class names

There are multiple ways to generate a union type out of all class names. One solution would be to use the ability to expand template literal type unions:

```typescript
type ColorName = 'red' | 'purple' | 'blue' | 'green'
type Luminance = 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
type Color = `${ColorName}-${Luminance}`
type Layout = 'block' | 'flex' | 'grid' | 'inline-block'

// Expands to all possible class names
type ClassName = Layout | `text-${Color}` | `bg-${Color}`
```

But it's a lot of work and the typings would need to be generated based on [tailwind.config.js](https://tailwindcss.com/docs/configuration). In addition, it would lead to a huge union type with more than 60 000 unique string literals.

Instead of template literal expansion, using [postcss-ts-classnames](https://github.com/esamattis/postcss-ts-classnames) eliminates the issues. It parses the output of PostCSS, exctracts all class names, and writes the union type of them to a `d.ts` file.

The result is a robust typing, that doesn't care about Tailwind's configuration or purging. It accurately captures all the class names your project has.

A downside is that a small lag is introduced to development:

* A new valid Tailwind class name is taken into use
* For a short while, IDE complains about the class not being valid
* PostCSS build is ran, which re-generates the `d.ts` types
* IDE does a TypeScript refresh, and the error is gone

Now we have `tailwindClassNames.d.ts` which contains a union type of all valid class names:

```typescript
type ClassName =
  | 'block'
  | 'inline-block'
  | 'flex'
  | 'grid'
  | 'bg-gray-100'
  // ... a thousand more
```

### 2. Trimming whitespace

Let's start with the leading whitespace. For this trick, we'll use [inference with template literals](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#inference-with-template-literals).


```typescript
// Newlines occur in multiline strings with backtick quotes
type Whitespace = ' ' | '\n'

// `extends string` validates that the
// type argument `T` is a string
type TrimStart<T extends string> =
  // Is `T` in format: ` ${Tail}` or `\n${Tail}`?
  T extends `${Whitespace}${infer Tail}`
    // Yes. Recursively call this utility again,
    // because Tail might contain new leading
    // whitespace.
    ? TrimStart<Tail>
    // No. Stop recursion.
    : T
```

Note that in each iteration of the recursive loop, only one whitespace character is "eaten" from the result at a time. This happens because in the conditional, the type argument `T` needs to exactly match the template `` `${Whitespace}${infer Tail}` ``. Since `Whitespace` can only be 1 character long, it consumes only one whitespace character at a time.

The type instantiation depth limit was [increased to 500](https://github.com/microsoft/TypeScript/pull/45025) in TypeScript, to support this exact use case better. It means that we can theoretically trim 500 leading whitespace characters at maximum. The amount decreases when the utility is a part of a larger type chain, which is often the case.

However, there's an optimization trick. You can pre-define a few different lengths of whitespaces to minimize the amount of depth required:

```typescript
type InstantiationDepthReducingWhitespace =
  // This will match first, consuming 3 leading spaces at once
  | '   '
  | '  '
  | ' '
  | '\n'
```

Neat! Now let's do the same for trailing whitespace and combine both:

```typescript
type InstantiationDepthReducingWhitespace =
  | '   '
  | '  '
  | ' '
  | '\n'

type TrimStart<T extends string> =
  T extends `${InstantiationDepthReducingWhitespace}${infer Tail}`
    ? TrimStart<Tail>
    : T

type TrimEnd<T extends string> =
  T extends `${infer Prefix}${InstantiationDepthReducingWhitespace}`
    ? TrimEnd<Prefix>
    : T

type Trim<T extends string> = TrimEnd<TrimStart<T>>
```

The end result:

```typescript
// type Result = "abc"
type Result = Trim<'\n\n  abc   '>
```



### 3. Split to tokens and validate

This is going to be a tough piece.

To ease the token processing, let's make a utility that converts `className` string into an array of tokens. Working with an array is easier than for example a string with space separated values.

The new utility called `SplitToTailwindClassNames` should do the following conversions:

Input | Output
------|-------
`"block bg-gray-100"` | `["block", "bg-gray-100"]`
`"\n\n block\n  p-1  "` | `["block", "p-1"]`
`" block invalid "` | `["block", never]`


We'll start with the familiar template literal inference. This time instead of consuming whitespace characters, we want to consume Tailwind class names.

```typescript
type SplitToTailwindClassNames<T extends string> =
  // Does `T` start with a Tailwind class name?
  T extends `${ClassName}${infer Tail}`
    // Yes. Continue consuming ClassName tokens with
    // next recursion iteration.
    ? [ClassName, ...SplitToTailwindClassNames<Tail>]
    // No. Stop recursion.
    : []
```

We can see that the utility now knows how to consume Tailwind class name tokens.

```typescript
// type Debug1 = []
type Debug1 = SplitToTailwindClassNames<' '>

// type Debug2 = [ClassName]
type Debug2 = SplitToTailwindClassNames<'block'>

// type Debug3 = [ClassName, ClassName]
type Debug3 = SplitToTailwindClassNames<'blockp-1'>

// Note: whitespace is not correctly handled yet!

// type Debug4 = [ClassName]
type Debug4 = SplitToTailwindClassNames<'block p-1'>
```

That's great but the array items are of type `ClassName`, which is the union type itself. What we really need is the actual tokens found, for example `['block', 'p-1']`.

There's no way in TypeScript to make a template literal match a token **and** assign it to a type variable at the same time. If TypeScript supported the feature, it could look something like this:

```typescript
T extends `${infer C extends ClassName}${infer Tail}`
// `C` would refer to the actual token
```

But it doesn't.

I couldn't find a solution anywhere online, which lead me to [ask the question](https://stackoverflow.com/questions/65844206/how-to-avoid-ambiquity-in-typescript-template-literal-type-inference/65846728) in Stack Overflow. It took a while to marinate, but finally a solution clicked in my head.

To get access to the first token, you can inverse the inference with a second template literal inference:

```typescript
type GetTokenTrick<T extends string> =
  T extends `${ClassName}${infer Tail}`
    ? T extends `${infer C}${Tail}`
      ? C
      // This shouldn't be possible to reach, as
      // we just inversed the matching
      : never
    : never
```

Now the utility captures the first token!

```typescript
// type Debug = "block"
type Debug = GetTokenTrick<'block<whatever>'>
```

Let's combine the knowledge so far and also deal with the whitespace by using `Trim<Tail>`.

```typescript
type SplitToTailwindClassNames<T extends string> =
  // Does `T` start with a Tailwind class name?
  T extends `${ClassName}${infer Tail}`
    ? T extends `${infer C}${Tail}`
      // Continue consuming ClassName tokens with
      // next recursion iteration.
      ? [C, ...SplitToTailwindClassNames<Trim<Tail>>]

      // This shouldn't be possible to reach, as
      // we just inversed the matching
      : never

    // Stop recursion.
    : []
```

Many cases are now dealt correctly, but there's still a few issues.


```typescript
// type Debug1 = ["block"]
type Debug1 = SplitToTailwindClassNames<'block'>
// type Debug2 = ["block", "p-1"]
type Debug2 = SplitToTailwindClassNames<'block p-1'>
// type Debug3 = ["block", "p-1"]
type Debug3 = SplitToTailwindClassNames<'block\n\np-1   '>

// Still not working:

// Whitespace at the beginning
type Debug4 = SplitToTailwindClassNames<' block'>  // []

// Errors are not dealt correctly,
// should be [never]
type Debug5 = SplitToTailwindClassNames<'invalid'>  // []
```

The easiest way to fix the leading whitespace issue is to make a wrapper utility that calls `Trim`:

```typescript
type Wrapper<T extends string> = SplitToTailwindClassNames<Trim<T>>
```

The error handling can be improved by separating the "invalid T" and "end recursion" cases:


```typescript
type SplitToTailwindClassNames<T extends string> =
  T extends `${ClassName}${infer Tail}`
    ? T extends `${infer C}${Tail}`
      ? [C, ...SplitToTailwindClassNames<Trim<Tail>>]
      : never

    // Added error handling
    // Handles cases where `T` does not match
    // ${ClassName}${Tail}. For example
    // 'block', '', '\n\n', 'invalid', or 'invalid  block'
    //
    // Note: `Tail` has already been trimmed from whitespace
    : T extends `${infer Tail}`
      ? Tail extends ClassName
        // `Tail` equals a valid Tailwind class.
        // End recursion succesfully.
        ? [Tail]
        : Trim<Tail> extends ''
          // `Tail` has only whitespace left.
          // End recursion succesfully.
          ? []
          // Something else was found.
          // Raise an error
          : [never]

      // Should never happen as `T` is a string.
      : [never]
```

Finally we got to a version that handles all the cases as expected.


### 4. Error messages

The built-in way to indicate a type error is to use [never](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-never-type). It works because `never` is not assignable to any other type.

In complex conditional types you might have multiple instances of `never` type, but for separate issues. This makes the code hard to read and type errors less descriptive. Unfortunately, TypeScript [doesn't natively support](https://github.com/microsoft/TypeScript/issues/23689) anything like `throw`.

However, there is a hack that achieves almost the same result. Instead of returning `never`, you can return the error message as a literal string:

```typescript
type IsValid<T extends string> =
  T extends ClassName
    ? T
    : `Error: '${T}' is not a valid Tailwind class`
```

The literal string error message works in a similar way as `never`. Types aren't assignable to it in practice. It's easiest to understand via an example:

```typescript
function cn<T>(singleClassName: IsValid<T>) {
  return singleClassName;
}

// Argument of type '"invalid"' is not assignable to parameter of type
// '"Error: 'invalid' is not a valid Tailwind class"'.
cn('invalid')
```

The passed parameter typed as literal `'invalid'` is not assignable to the error message that's also a literal string type.


### 5. Object and array formats

The string format has already been covered, but there's still objects and arrays.

The object format:

```js
{
  'block p-1': size === 'xl'
}
```

Array format:

```js
[
  'block p-1',
  {
    'block p-1': size === 'xl'
  }
]
```

Let's start with the simpler object format.

Proceed to tell about mapped types.


Next, let's figure out the array format.

Proceed to tell about array recursion.


## Combining everything

With the individual pieces solved, it's time to put everything together.

Proceed to explain how.

Final playground link.



## Credits & further reading

The final types took quite a while to finish, and I couldn't have done it without help. Credits to [@ahejlsberg](https://github.com/ahejlsberg), [@virtualkirill](https://twitter.com/virtualkirill), and [@jcalz](https://stackoverflow.com/users/2887218/jcalz) for terrific online resources.

* [Make your CSS safer by type checking Tailwind CSS classes](https://dev.to/virtualkirill/make-your-css-safer-by-type-checking-tailwind-css-classes-2l14)
* [How to type check if object keys conform a conditional recursive template type?
](https://stackoverflow.com/questions/65737948/how-to-type-check-if-object-keys-conform-a-conditional-recursive-template-type/65738172#65738172)
* [Pull request](https://github.com/microsoft/TypeScript/pull/40336) that introduces template literal types
* [awesome-template-literal-types](https://github.com/ghoullier/awesome-template-literal-types)
* [Type Gymnastics](https://github.com/g-plane/type-gymnastics) – Collection of wonderful TypeScript type gymnastics code snippets
* [ts-sql](https://github.com/codemix/ts-sql) – SQL "database" implemented purely in TypeScript.
* [XML parser in TypeScript](https://github.com/0kku/destiny/blob/a3d5182658599bc117db3b4657fed71dfedf8b44/src/parsing/XmlTypeParser.ts)
* [ts-metacode](https://github.com/gmono/ts-metacode)
